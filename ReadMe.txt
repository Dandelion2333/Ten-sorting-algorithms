此项目的目的：
    1、学习数据结构中的十种排序算法，具体涉及到算法的原理、算法的实现方法、算法的相关知识
    2、使用Python作为实现工具，进一步加深对Python的学习

项目开始的时间：
    2020.02.04  周二

项目进度：
2020.02.04  周二    （V1.0）
    1、建立基本数据结构，数组数据形成
    2、实现选择排序

2020.02.08  周六
    1、学习、实现快速排序
    2、学习、实现插入排序

2020.02.09  周日    （V2.0）
    1、学习、实现希尔排序
    2、增加时间复杂度可视化，把排序中的交换与比对的次数打印可视
    3、增加排序算法的运行时间记录功能
    4、学习、实现冒泡排序
    5、添加十种排序的详细信息图片

2020.02.12  周三
    1、学习、并用不同的方式实现堆排序
    2、深入理解堆排序，通过看网上的教程，自己用代码实践，与大佬F探讨、听从其教诲
    3、优化冒泡排序

2020.02.13  周四
    1、学习、并实现归并排序
    2、深入理解递归的精髓，使用的场景
    3、通过学习递归，进一步加深对快速排序算法的理解。

名词定义：
    1、稳定性： 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，
        ri=rj，排序之后仍然ri=rj。进一步讲，排序前ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；
        否则称为不稳定的。

算法原理及属性：
    1、选择排序
        1、原理
            每次都选择数组中最小的数，将其依次从第零个放入，直到最后。
        2、属性
            时间复杂度：由于每次都会遍历一遍数组，选出最小的数据。假设有n个数据，则总共需要比对n²。也就是平均复杂度为n²，同理最坏情况下也是如此。
                那么，最好的情况呢？其实也是，原因为，即使是顺序排列，按照原理可知，也需要两个循环。
            空间复杂度：不会暂用其他空间，只要本数组即可，即为1。
            稳定性：为不稳定。
                用数组5,8,5,2,9的例子解释。第一次，选择2为最小值，其与第零位的5交换位置，那么，排序后两个五的相对位置与排序前的
                    相对位置就产生了变化。即为不稳定的

    2、快速排序
        1、原理
            选择第一个数作为基数，比它小的放左边，比它大的放右边，完成一轮对比之后，以基数作为分界线，左右两边两组数据，再用同样的方法排序
                直到最终排序完成
        2、属性
            时间复杂度：平均的时间复杂度为O(nlogn)，最好的情况也是如此，最坏的情况是n²
            空间复杂度：由于用到了递归，所以，空间复杂度为：O(nlogn)
            稳定性：为不稳定
                这个很好理解，就拿两个相同的数来说，在比对、交换的过程中，他们之间的相对位置肯定会被改变。
        3、其他
            快速排序的理论核心在于与基数的比对，然后产生两组特别数据，然后对这两组是数据进行与上个步骤相同的处理
            既然都为相同操作，那么就用用到递归，在代码上要特别注意递归的使用，所以引入begin与end是非常好的操作。

    3、插入排序
        1、原理
            可以看作是把一个数据插入到一个有序数据中，一般都是从后面插入。
            从第一个开始，它已经是有序数据了，将他与第二个进行比较，假如大于后者，则把后者插入到前面。
        2、属性 
            时间复杂度：由于它也是两曾循环，所以平均复杂度肯定是n²，最坏的情况也是如此。最好的情况则是排好顺序的数据，则第二层循环用不上
                不需要移动数据，所以为n
            空间复杂度：不会暂用其他空间，只要本数组即可，即为1。
            稳定性：为稳定 
                因为插入的原则是，当两个数据相同时，不用处理，也就是不用插入到前一个数据的前面，那么他们的相对位置就没有任何变化。
        3、其他
            我在实现插入排序时，把问题复杂化了，用了很多变量来表示，结果越来越乱。解决问题的关键在于要插入的数据与它的编号。然后根据编号
                向左移动，此时的移动用一个while循环做，判断的条件是插入数据大于它的前一个数据。
    4、希尔排序
        1、原理 
            插入排序的进阶版。
            按照一定的间隔h,选取一个数据，组成一组新的数组，相应的会产生h组数据，然后对这些数组使用插入排序。
            然后，使用二分之h作为间隔，重复上述步骤，直到h等于1。这种排序方式为希尔排序
        2、属性
            时间复杂度：平均时间复杂度为O(n的1.3次方)，最后的情况是n，最差的情况是n²
            空间复杂度：不会暂用其他空间，只要本数组即可，即为1。
            稳定性：为不稳定
                这个很好理解，按照一定的间隔取了数据之后，原来的相对关系肯定被改变了。
        3、其他
            while leftCnt > (begin - gap) and ShMatrix[leftCnt] > insertValue:
            这句特别关键，leftCnt大于的数值是从开始的位置往左边移动对应间隔的距离。

    5、冒泡排序
        1、原理
            从第一二个数开始比较，较大的数放后面，然后再第二三个数进行比较，较大的数放后面，一直比较到最后一个数
            所以，数组中最大的数就像冒泡的样子，移到了最后。这便是第一轮操作。
            同理，第二轮操作与第一轮一模一样。
        2、属性 
            时间复杂度：由于有两层循环，所以，平均时间复杂度为O(n²)，最坏的情况也是如此
                最好的情况是已经排好序了，所以只要一层循环就够了。
            空间复杂度：不会暂用其他空间，只要本数组即可，即为1。
            稳定性：为稳定
                因为在冒泡的过程中，是两者进行大小比对，不会改变数据的相对位置
        3、其他
            1、冒泡排序相对简单，但是可以参考别的大神用非常简洁的方式实现这套算法。
            2、内层循环与外层循环要相互“独立”，互相直接尽量不要牵扯。这样的目的是使算法更简单明了，也不易出错
            3、用外层循环的次数控制内层循环
        4、特别补充
            1、对于一个已经排好序的数组来说，时间复杂度为n。因为，冒泡的性质决定，当第一轮比对过后，没有数据交换，第二层循环就不会执行
    
    6、堆排序
        1、原理
            1、使用完全二叉树作为基本堆结构。(完全二叉树的定义为：除了最后一层外，其他层都被完全填满，且最后一层是想向左对齐)
            2、构建一个大根堆(升序用大根堆，降序用小根堆)
                构建的方法是，找到最后一个非叶子节点，将其作为父节点，并于子节点做比较，取最大的数值放置父节点。
                    然后再使用倒数第二个非叶子节点，做同样的操作，直到遍历到根节点。
                补充：倒数第一个非叶子节点为：(length/2)-1。 
                再补充：由于我们要构建大根堆，所以，每一个父节点相对于子节点来说，都是他们之间的较大值。
                    所以，我们在构建的过程中，要特别注意当一个父节点产生变化时，一定要与其子节点再次比较。确保都是大根堆
            3、把数组的最后一个数与第一个数交换位置。经过第二个步骤的操作，第一个数俨然是本数组中的最大值。
            4、从根节点开始，把父节点与子节点比较，取其较大的值，因为第二步我们已经构建了大根堆，根据大根堆的性质，根节点的左右两个孩子
                是本数组中最大的两个值。当根节点与其中一个孩子交换之后，他需要继续与他此时的孩子作比较(参考第二步的《再补充》部分)
                经过本次递归之后，再使用步骤三。然后再重复步骤四。
            5、循环停止的条件为，步骤四重复了数组元素总个数减一次。
        2、属性
            时间复杂度：平均、最好、最差的时间复杂度都为O(nlogn)。这么说来，他还是很稳定的嘛
            空间复杂度：由于在运算过程中使用的空间都为常数量级，所以空间复杂度为1
        3、其他 
            1、特别注意再补充的部分。
            2、理解堆排序的原理

    7、归并排序
        1、原理
            1、把一个数组分割成len(arr)个单独的数组，每个数组都是一个元素
            2、把这些数组看成是已经排好序的有序数组。
            3、用递归的思想对有序数组排序，最终把整个数组排好序
        2、属性
            1、时间复杂度：由于递归的深度为log2的n，遍历一次为n，所以，无论情况好坏，都是nlog2的n
            2、空间复杂度：由于要用到额外的空间，所以其复杂度为n
            3、稳定性：通过它的原理可知，他是稳定的。
        3、其他
            1、注意递归的写法，这个很神奇。
        

